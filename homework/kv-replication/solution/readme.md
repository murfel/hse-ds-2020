# kv-replication решение

## Кларификация условия

Контекст (метаданные), передаваемый с запросами на запись и с ответами на чтение, — это не что иное, как вектор версий (4.1 System Interface). Если на запись передаётся пустой контекст, это значит, что записывается новый объект.

Предполагается, что **минимальные** кворумы R и W, передаваемые пользователем, удовлетворяют R + W > N и фиксированы во время работы одного инстанса системы. (Удовлетворяется в тестах.)

## Реализация

Далее версия — это векторные часы вида List[Tuple[node, counter]]. При каждом действии (get, put, отправить сообщение, todo: точно в этих случаях?), counter ноды увеличивается. Часы ноды посылаются в каждом сообщении (todo: а надо ли так?)

Для упрощения используется кольцевое хеширование с одним токеном на каждую ноду (а не несколько), т.к. в тестах не проверяется, что данные сбалансированы, и что при join/leave мигрирует не очень большое количество данных.

Join/leave производится так же, как и в kv-sharding. При join нода посылает свой токен сиду, сид записывает токен ноды и высылает ноде список членов группы и список всех токенов, нода записывает токены и приветсвутет всех членов, члены в ответ посылают ноде пары ключ-значение, которые теперь должны пренадлежать ноде. При Leave каждой ноде рассылаются просьба удалить токен уходящей ноды и новые ключи ноды, если такие есть. Что такое confirmation раунд в статье про Dynamo, я не поняла, но скорее всего я его не делаю:)

Для упрощения госсипинг о состоянии членства в группе не производится (кроме как при join/leave). Если был нетворк партишен, мы можем не доузнать о членстве, но раз в тестах не проверяется, можно упростить.

Нода D на кольце с токенами A-G считается репликой для ключей в промежутках [A, B), [B, C), [C, D). Причём для промежутка [C, D) нода D считается координирующей для запросов на запись, т.е. запросы на запись будут перенаправляться ей. В случае её недоступности, запросы на запись будут передаваться следующей ноде E и т.д. (hinted handoff, описан далее).

Get(key, quorum) -> List[Tuple[value, version]]. При запросе на чтение, нода получившая запрос, посылает внутренний асинхронный запрос на чтение всем репликам, хранящим этот ключ. (Если она тоже хранит этот ключ, тогда она также получит ответ от себя). При получении quorum ответов, нода реконсилиирует версии и присваивает этому объекту новую версию v, большую всех остальных версий. Отвечает клиенту, и посылает внутренний запрос на запись реконсилиированной версии ноды, каждой реплике, ответственной за ключ. При этом нода не контроллирует, получили ли реплики запрос на запись. Если реплики пропустят запись реконсилиированной версии, эта версия утеряется.  TODO: это ведь плохо? ведь юзер может попросить обновить эту версию. Если внутренний запрос на чтение затаймаутился, получив менее, чем quorum ответов, юзеру возвращается реконсилиация с новой версией от того, что есть. Если ответов ноль, возвращается значение по умолчанию (пустая строка), с новой версией. Такой ответ так же записывается в реплику (или официальную, или ближайшую по кругу, если из официальных не набирается кворум). NB: запись реконсилиированного объекта производится стандартным внутренним механизмом записи put с quorum = N - get_quorum + 1. (почти, что там насчёт векторов? TODO надо думать) 

Реконсилиация версий: если v1 <= v2, то v1 выкидывается. Иначе объекты с версиями v1 и v2 объединяются в множество. Реализация: внутренние get запросы возвращают список. При получении ответа нескольких реплик на внутренние get запросы, ответы объединяются в один список и скармливаются процедуре reconcile. Эта процедура за квадрат сравнивает все векторы версий и возвращает список несравнимых векторов (casually unrelated versions). Для ключей с префиксом `cart` реализована допфункция семантической реконсилиации с семантикой корзины для покупок. В отличие от Dynamo, vector clock truncation не производится, векторные часы могут быть произвольного размера.

Put(key, List[version]) -> None.  При операции записи передаём внутренний запрос на запись в координирующую ноду (первую реплику, если недоступна — во вторую и т.д.). Координатор записывает его локально (без реконсилиации, только добавляет в список с другими версиями; NB: этот список не плоский). Новая версия не присваивается.

Sloppy quorum: при достижении таймаута операции put или get, если не набралось кворум ответов от реплик или их заместителей, операция всё равно выполняется с тем, что есть и ответ отдаётся пользователю.

Hinted handoff: изначально запрос посылается на все официальные реплики. При недостатке ответов в количестве Х через маленький таймаут, запрос посылается на следующие Х за последней репликой нод с пометкой в метаданных, что он является hinted handoff. При неполучении еще за маленький таймаут, на следующие и т.д. Hinted handoff используется как при передаче запроса на запись на координирующую ноду, так и при непосредственно внутреннем запросе на запись или чтение.

При получении hinted handoff версии, нода должна начать опрашивать настоящую реплику. При обнаружении её в онлайне, она передаёт ей её данные и удаляет hinted данные у себя. NB: нода может являться временной репликой для нескольких других нод.

Векторные часы. При получении запроса на **инициацию записи** нодой-координатором, нода увеличивает свои часы, присваивает новую версию объекту, и рассылает внутренние запросы на запись. При получении внутреннего запроса на запись от ноды-координатора, версия объекта не меняется. Аналогично, при чтении увеличение часов происходит после того, как реконсилиированныая версия была получена координатором на инициацию записи. 

Обратите внимание, что в качестве контекста передаётся список версий (мб длины 0 или 1). После записи считается, что эти версии реконсилиировались (это происходит автоматически, т.к. векторные часы записывателя будут >= всех векторов версий).


Разбивка на итерации по тестам:
BasicTestCase - простой join (только начальный, без передачи данных) и вспомогательные функции скопировать из kv-sharding, put и get всегда имееют достаточно живых реплик, чтобы получить ответ с кворумом. Фиктивная метадата, примитивное разрешение версий (у всех одинаковые значения => вернуть нулевой объект).
ReplicasCheckTestCase - то же самое, проверяет что ровно 3 реплики.
StaleReplicaTestCase - (посылаем в 0 v1 с кворумом 3, отключаем 2, посылаем в 0 v2 с кворумом 2, отключаем 0, подключаем 2, спрашиваем 2 с кворумом 2 (проверка разрешения конфликтов с каузальной зависимостью), через много шагов отрезаем 2 и спрашиваем 2 с кворумом 1) - проверяет разрешение конфликтов с каузальной зависимостью и eventual consistency - дописать разрешение версий с записью разрешенной версии при get во все доступные реплики (пока что без hinted handoff)
ReplicasDivergenceTestCase - 
SloppyQuorumTestCase
PartitionedClientTestCase
PartitionedClientsTestCase
ShoppingCartTestCase
NodeJoinTestCase
NodeLeaveTestCase

Дизайндок написала, а на код уже времени не хватило :)

